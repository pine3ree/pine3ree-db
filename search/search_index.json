{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pine3ree-db","text":"<p><code>pine3ree\\Db</code> is a small database abstraction layer on top of the <code>\\PDO</code> library.</p> <p>It provides a simple sql builder and convenience methods for common CRUD opeations.</p> <p>The DBAL instance consists of a simple PDO connection wrapper that can either use an existing connection or instantiate a new lazy pdo connection on demand.</p> <p>Basic database operations for retrieving, inserting, updating and deleting rows from/into a given database table leverage a set of database Command classes, which in turn compose the database connection itself and a corresponding sql abstraction statement object.</p> <p>The sql-command building operations are forwarded to the composed sql abstraction layer object, while the sql statement preparation, parameter binding and command execution are performed by the composed DBAL instance.</p>"},{"location":"#installation","title":"Installation","text":"<p>pine3ree-db DBAL requires php &gt;= 7.4 and can be installed via composer</p> <pre><code>$ composer require pine3ree/pine3ree-db\n</code></pre> <p>The package does not provide any stable version yet, so <code>\"minimum-stability\": \"dev\"</code> setting is required in your <code>composer.json</code> file.</p>"},{"location":"#features","title":"Features","text":"<p>The library's code is splitted into two main sections/namespaces:</p> <ul> <li> <p>a <code>Sql</code> section in which sql generation of full statements or smaller fragments   is abstracted</p> </li> <li> <p>a <code>Command</code> section which offers objects that actually send the sql statements   to the database server by means ot the composed connection and retrieve the results of   such operations such as row/record set for DQL statements and of number of   affected rows for DML statements.</p> </li> </ul>"},{"location":"db/","title":"pine3ree\\Db","text":""},{"location":"db/#note","title":"Note:","text":"<p>Unless differently specified, all the examples in the guide will use standard ANSI quotes <code>\"</code> to wrap identifiers inside SQL expressions.</p>"},{"location":"db/#quick-start","title":"Quick start","text":"<pre><code>use pine3ree\\Db;\nuse pine3ree\\Db\\Factory\\DbFactory;\nuse PDO;\n\n// 1. Create a dbal instance using an existing PDO connection\n$pdo = new PDO('my-db-dsn', 'my-db-username', 'my-db-password');\n$db = new Db($pdo);\n\n// 2. Create a dbal instance using pdo configuration: the PDO connection is created on demand\n$db = new Db('my-db-dsn', 'my-db-username', 'my-db-password');\n\n// 3. Create a dbal instance using a factory: the provided factory fetch a configuration\n// array from a psr-container under the `config` id/alias with specific database\n// configuration subarray under either a `db` or `pdo` key.\n$factory = new DbFactory();\n$db = $factory($container);\n\n// 4. Create a dbal instance using a factory method directly from database/pdo\n// configuration array:\n$db = DbFactory::create([\n    'driver'   =&gt; 'mysql',\n    'host'     =&gt; 'localhost',\n    'port'     =&gt; 3306,\n    'database' =&gt; 'testdb',\n    'username' =&gt; 'testuser',\n    'password' =&gt; 'secret',\n    'charset'  =&gt; 'utf8',\n]);\n\n// Simple proxy method to \\PDO::query() returning a traversable PDOStatement or\n// false if query execution fails\n$stmt = $db-&gt;query('SELECT * FROM product WHERE price &lt; 100.0 AND id &lt; 100');\n\n// Simple proxy method to \\PDO::exec(), returns the number of affected rows, or\n// false if execution fails\n$affected = $db-&gt;exec('UPDATE product SET published = FALSE WHERE stock &lt;= 0');\n</code></pre> <p>Other examples:</p> <pre><code>// Fetch all rows from the \"product\" table\n// fetchAll(string $table, $where = null, $order = null, int $limit = null, int $offset = null): array\n$products = $db-&gt;fetchAll('product');\n\n// Fetch the product row with column id = 42\n// fetchOneBy(string $table, string $column, $value, $order = null): ?array\n$product = $db-&gt;fetchOneBy('product', 'id', 42);\n\n// Same row using `fetchOne()` with condition in array-format\n// fetchOne(string $table, $where = null, $order = null): ?array\n$product = $db-&gt;fetchOne('product', ['id' =&gt; 42]);\n\n$fiftyExpensiveProducts = $db-&gt;fetchAll(\n    'product', [ // conditions array start\n        ['price', '&gt;', 1000.00], // 1 conditions in array-format\n    ], // conditions array end\n    [\n        'price' =&gt; 'ASC',\n    ],\n    50\n);\n\n$tenMostExpensiveProducts = $db-&gt;fetchAll('product', null, ['price' =&gt; 'DESC'], 10);\n\n$mostExpensiveProduct = $db-&gt;fetchOne('product', null, ['price' =&gt; 'DESC']);\n</code></pre>"},{"location":"db/#constructor-arguments","title":"Constructor arguments","text":"<p><code>pine3ree\\Db</code> supports the same constructor arguments as the <code>\\PDO</code> class.</p> <p>It also supports an extra argument, an optional custom PDO subclass to use in lazy connection instances.</p> <pre><code>class Db\n{\n   /**\n     * @param string|PDO $dsn_or_pdo A valid pdo dsn string or an existing pdo connection instance\n     * @param string|null $username PDO connection username\n     * @param string|null $password PDO connection password\n     * @param array|null $options PDO connection options\n     * @param string|null $pdoClass An optional PDO subclass to use when creating a new connection\n     */\n    public function __construct(\n        $dsn_or_pdo,\n        string $username = null,\n        string $password = null,\n        array $options = null,\n        string $pdoClass = null\n    ) {\n}\n//...\n</code></pre> <p>The first argument can also be an existing PDO instance itself, that will be used as the composed pdo connection.</p>"},{"location":"db/#factory-configuration-parameters","title":"Factory configuration parameters","text":"<p>Factory configuration retrieved from the container should return an array like the one below:</p> <pre><code>// file config.php\nreturn [\n    // full dsn specification\n    'db' =&gt; [ // alt key: 'pdo' =&gt; [...]\n        'dns'      =&gt; 'mysql:dbname=testdb;host=localhost;port=3306;charset=utf8',\n        'username' =&gt; 'testuser', // alt key: 'user'\n        'password' =&gt; 'secret', // alt key: 'passwd' or 'pass'\n    ],\n    // ...or single parameters specs\n    'db' =&gt; [\n        'driver'   =&gt; 'mysql',\n        'dbname'   =&gt; 'testdb', // alt key: 'database'\n        'host'     =&gt; 'localhost', // alt key: 'hostname'\n        'port'     =&gt; 3306,\n        'charset'  =&gt; 'utf8',\n        'username' =&gt; 'testuser', // alt key: 'user'\n        'password' =&gt; 'secret', // alt key: 'passwd' or 'pass'\n        'options'  =&gt; [\n            // pdo-options array\n        ]\n    ],\n];\n</code></pre> <p>The database configuration subkeys depend on the db driver used and must be all in snake_case format. Please check the pdo driver page https://www.php.net/manual/en/pdo.drivers.php for more information.</p> <p>The factory will attempt to build a valid pdo DSN with the provided configuration parameters.</p> <p>Supported drivers are <code>mysql</code>, <code>pgsql</code>, <code>sqlite</code>, <code>sqlsrv</code> and <code>oci</code>.</p>"},{"location":"db/#crud-commands","title":"CRUD commands","text":"<p>To start building a crud databse command you can use the following methods:</p> <pre><code>$select = $db-&gt;select(); // returns a pine3ree\\Db\\Command\\Select instance\n$insert = $db-&gt;insert(); // returns a pine3ree\\Db\\Command\\Insert instance\n$update = $db-&gt;update(); // returns a pine3ree\\Db\\Command\\Update instance\n$delete = $db-&gt;delete(); // returns a pine3ree\\Db\\Command\\Delete instance\n</code></pre> <p>Database command instances provide a fluent interface for building sql statement. The sql build is actually perfomed by the composed sql-statement (<code>pine3ree\\Db\\Sql\\Statement</code>) instance with the help of the sql-driver (<code>pine3ree\\Sql\\DriverInterface</code>) created for the current connection.</p> <p>The corresponding sql-statement objects ca be created with the following <code>pine3ree\\Db\\Sql</code> helper class static methods:</p> <pre><code>$select = Sql::select(); // returns a pine3ree\\Db\\Sql\\Statement\\Select instance\n$insert = Sql::insert(); // returns a pine3ree\\Db\\Sql\\Statement\\Insert instance\n$update = Sql::update(); // returns a pine3ree\\Db\\Sql\\Statement\\Update instance\n$delete = Sql::delete(); // returns a pine3ree\\Db\\Sql\\Statement\\Delete instance\n</code></pre> <p>The <code>Sql\\Statement</code> classes, as any other <code>Sql\\Element</code> class, provide a <code>getSQL()</code> method which compiles the sql string for the given sql-driver argument or the default <code>Ansi</code> driver. The sql-drivers provide identifier quoting and other sql transformations according to the underlying platform. The <code>getSQL()</code> method also collects user-provided parameter values along with their pdo-param types and sets named markers in their place into the sql string. The paramater collector can be retrieved by <code>getParams()</code> either from the sql-statement object or the wrapping command. A internal collector will be created only if not passed-in as the 2nd argument of the <code>getSQL()</code> call.</p> <p>All database command classes implement the <code>execute()</code> method.</p> <ul> <li>For writer-DML-commands (Insert|Update|Delete) <code>execute()</code> will call the writer   method <code>Writer::exec()</code> and will return either the number of rows affected or   <code>false</code> on failure.</li> <li>For reader-DQL-commands (Select) <code>execute()</code> will call the reader method   <code>Reader::query()</code> and will return either a traversable <code>\\PDOStatement</code>   result-set object or <code>false</code> on failure.</li> </ul> <p>Unless otherwise stated in all the examples' compiled sql-strings identifiers and aliases will be quoted according to an implied <code>Ansi</code> driver, i.e. using double quotes <code>\"</code>.</p>"},{"location":"db/#dbselect","title":"Db::select()","text":"<p>Create a <code>pine3ree\\Db\\Command\\Select</code> reader command instance</p> <pre><code>use pine3ree\\Db;\nuse pine3ree\\Db\\Sql;\n\n/** @var Db $db */\n\n$select = $db-&gt;select(); // create a generic empty Select command instance\n\n// SELECT * FROM \"product\"\n$select = $db-&gt;select('*', 'product');\n$select = $db-&gt;select('*')-&gt;from('product');\n$select = $db-&gt;select(null, 'product');\n$select = $db-&gt;select()-&gt;from('product');\n\n// Use table alias: SELECT * FROM \"product\" \"p\"\n$select = $db-&gt;select('*', 'product', 'p');\n$select = $db-&gt;select('*')-&gt;from('product', 'p');\n$select = $db-&gt;select()-&gt;from('product', 'p');\n\n // SELECT \"p\".\"price\", \"p\".\"vat_rate\" AS \"vatRate\" FROM \"product\" \"p\"\n$select = $db-&gt;select(['price', 'vatRate' =&gt; 'vat_rate'])-&gt;from('product', 'p');\n\n// Add where condition LessThanEqual and order-by clause\n$select-&gt;where-&gt;lte('price', 1000.0); // WHERE \"price\" &lt;= :lte1 (named parameter marker)\n\n// ORDER BY \"p\".\"price\" ASC\n$select-&gt;orderBy('p.price', 'ASC');\n$select-&gt;orderBy('p.price', Sql::ASC);\n\n// ORDER BY \"price\" ASC, \"vat_rate\" DESC\n$select-&gt;orderBy([\n    'price' =&gt; Sql::ASC, // or just 'price' =&gt; 'ASC'\n    'vat_rate' =&gt; Sql::DESC, // or just 'vat_rate' =&gt; 'DESC'\n]);\n\n$stmt = $select-&gt;execute(); // or $select-&gt;query(), returns a \\PDOStatement instance or FALSE\n\n// SELECT\n//    \"category_id\" AS \"catId\",\n//    COUNT(*) AS \"numProducts\"\n// FROM \"product\" WHERE \"price\" &gt; :gt1\n// GROUP BY \"category_id\"\n// HAVING \"numProducts\" &gt;= :gte1\n$select = $db-&gt;select()\n    -&gt;column('category_id', 'catId')\n    -&gt;count('*', 'numProducts')\n    -&gt;from('product');\n    -&gt;where-&gt;gte('price', 10.0);\n// using $select-&gt;where or $select-&gt;having changes the scope and the fluent interface\n// method chain is broken\n\n// Add a GROUP BY\n// GROUP BY \"category_id\" HAVING \"numProducts\" &lt; :lte1\n$select-&gt;groupBy('category_id')\n    -&gt;having-&gt;lte('numProducts', 5);\n\n// SELECT MIN(\"price\") FROM \"product\" GROUP BY \"category_id\"\n$select = $db-&gt;select()-&gt;min('price')-&gt;from('product')-&gt;groupBy('category_id');\n</code></pre>"},{"location":"db/#dbinsert","title":"Db::insert()","text":"<p>Create and optionally execute an <code>pine3ree\\Db\\Command\\Insert</code> writer command instance.</p> <pre><code>// INSERT INTO \"product\" (\"name\", \"price\") VALUES (:val1, :val2)\n$insert = $db-&gt;insert()\n    -&gt;into('product')\n    -&gt;row([\n        'name' =&gt; 'product-1',\n        'price' =&gt; 100.00,\n    ]);\n\n// equivalent to\n$insert = $db-&gt;insert()\n    -&gt;into('product')\n    -&gt;columns(['name', 'price'])\n    -&gt;values(['product-1', 100.00]);\n\n$result = $insert-&gt;execute() // or $insert-&gt;exec(), returns TRUE or FALSE for single row insert\n</code></pre> <p>Insert and execute shortcut call, when both arguments (<code>$table</code> and <code>$row</code>/<code>$rows</code>) are provided:</p> <pre><code>$result = $db-&gt;insert('product', [\n    'name' =&gt; 'product-111',\n    'price' =&gt; 111.11,\n]); // returns TRUE or FALSE for single insert\n\n// get the last generated value if the insert is successful\n$id = $result ? $db-&gt;lastInsertId() : null;\n</code></pre> <p>Insert many rows:</p> <pre><code>// INSERT INTO \"product\" (\"name\", \"price\") VALUES (:val1, :val2), (:val3, :val4)\n$num_inserted = $db-&gt;insert('product', [\n    [\n        'name' =&gt; 'product-111',\n        'price' =&gt; 111.11,\n    ],\n    [\n        'name' =&gt; 'product-222',\n        'price' =&gt; 222.22,\n    ],\n]); // returns integer or FALSE for multi-rows inserts\n\n// equivalent to\n$num_inserted = $db-&gt;insert()\n    -&gt;into('product')\n    -&gt;rows([\n        [\n            'name' =&gt; 'product-111',\n            'price' =&gt; 111.11,\n        ],\n        [\n            'name' =&gt; 'product-222',\n            'price' =&gt; 222.22,\n        ],\n    ])-&gt;execute(); // or exec()\n\n// and to\n$num_inserted = $db-&gt;insert()\n    -&gt;into('product')\n    -&gt;columns(['name', 'price'])\n    -&gt;values([\n        'product-111',\n        111.11,\n    ])\n    -&gt;values([\n        'product-222',\n        222.22,\n    ])-&gt;execute(); // or exec()\n\n// and to\n$num_inserted = $db-&gt;insert()\n    -&gt;into('product')\n    -&gt;columns(['name', 'price'])\n    -&gt;multipleValues([\n        [\n            'product-111',\n            111.11,\n        ],\n        [\n            'product-222',\n            222.22,\n        ],\n    ])-&gt;execute();\n</code></pre> <p>By default <code>Insert::values(array $values, bool $reset = false)</code> and <code>Insert::row(array $row, bool $reset = false)</code> will add new inset values to existing ones. This can be changed by setting the 2nd argument to <code>true</code>:</p> <pre><code>$insert = $db-&gt;insert('product');\n\n$insert-&gt;row(['price' =&gt; 111.11, 'stock' =&gt; 111]); // adds 1 set of values\n$insert-&gt;row(['price' =&gt; 222.22, 'stock' =&gt; 222]); // adds 1 set of values\n// columns \"price\" and \"stock\" are alredy specified by previuous row() calls\n$insert-&gt;values([333.33, 333]); // adds 1 set of values\n\n$insert-&gt;execute(); // this will try to insert 3 rows\n\n$insert-&gt;values([444.44, 444]); // adds another set of values\n$insert-&gt;execute(); // this will try to insert 4 rows\n\n // adds 1 set of values after removing the old ones\n$insert-&gt;row(['price' =&gt; 555.55, 'stock' =&gt; 555], true);\n$insert-&gt;execute(); // this will try to insert 1 row\n</code></pre> <p>The opposite happens for <code>Insert::rows(array $rows, bool $reset = true)</code> and <code>Insert::multipleValues(array $values, bool $reset = true)</code>. These methods calls will insert the exact rows/values provided unless the 2nd argument is set to <code>false</code>.</p>"},{"location":"db/#dbupdate","title":"Db::update()","text":"<p>The <code>pine3ree\\Db\\Command\\Update</code> command abstracts an INSERT operation</p> <p>A non empty condition/predicate is required, otherwise an exception is thrown.</p> <p>Examples:</p> <pre><code>// UPDATE \"product\" SET \"published\" = :set1 WHERE stock &gt; 0\n$update = $db-&gt;update()-&gt;table('product')-&gt;set('published', true)-&gt;where('stock &gt; 0');\n$update = $db-&gt;update('product')-&gt;set('published', true)-&gt;where('stock &gt; 0');\n$affected = $update-&gt;execute(); // or exec()\n\n// Immediate command execution\n// UPDATE \"product\" SET \"published\" = :set1 WHERE TRUE, we use the condition \"TRUE\" to update all records\n$affected = $db-&gt;update('product', ['published' =&gt; true], 'TRUE');\n</code></pre>"},{"location":"db/#dbdelete","title":"Db::delete()","text":"<p>The <code>pine3ree\\Db\\Command\\Delete</code> command abstracts a SQL DELETE operation</p> <p>A non empty condition/predicate is required, otherwise an exception is thrown.</p> <p>Examples:</p> <pre><code>// DELETE FROM \"product\" WHERE stock &lt;= 0\n$delete = $db-&gt;delete()-&gt;from('product')-&gt;where('stock &lt;= 0');\n$delete = $db-&gt;delete('product')-&gt;where('stock &lt;= 0');\n$num_deleted = $delete-&gt;execute(); // or exec()\n\n// immediate command execution\n// DELETE FROM \"product\" WHERE stock &lt;= 0\n$num_deleted = $db-&gt;delete('product', 'stock &lt;= 0');\n</code></pre>"},{"location":"db/#sql-driver-proxy-helper-methods","title":"Sql driver proxy helper methods","text":"<p>The following methods are simple proxies to methods implemented in the <code>pine3ree\\Db\\Sql\\DriverInterface</code> class of the current dbal's sql-driver instance.</p> <ul> <li><code>Db::quoteIdentifier(string $identifier)</code> quotes given column/table SQL identifier</li> <li><code>Db::quoteAlias(string $alias)</code> quotes given SQL aliase</li> <li><code>Db::quoteValue(null|scalar $value)</code> perform type-casting and quotes - when required - the given value</li> </ul>"},{"location":"sql/clauses/","title":"pine3ree\\Db\\Sql\\Clause","text":""},{"location":"sql/clauses/#pine3reedbsqlclausejoin","title":"pine3ree\\Db\\Sql\\Clause\\Join","text":""},{"location":"sql/drivers/","title":"Drivers","text":""},{"location":"sql/drivers/#pine3reedbsqldriverinterface","title":"pine3ree\\Db\\Sql\\DriverInterface","text":""},{"location":"sql/elements/","title":"Elements","text":""},{"location":"sql/elements/#pine3reedbsqlelementinterface","title":"pine3ree\\Db\\Sql\\ElementInterface","text":"<p>A sql element represents full sql statements or just part of it such as identifiers, aliases, predicate, clauses, etc...</p> <p>It provides a <code>getSQL(DriverInterface $driver = null, Params $params = null)</code> method that returns the compiled SQL-string for the elements itself with the help of the given driver and collects parameter values and types to be used when the sql-statements are being prepared to be sent to the database server.</p> <p>Sql elements can also be organized in hierarchies (<code>ElementInterface::setParent()</code>), but an element can have only one parent. Changes to an inner element must invalidate any compiled sql-string that has been cached.</p>"},{"location":"sql/elements/#pine3reedbsql","title":"pine3ree\\Db\\Sql","text":"<p>The <code>Db\\Sql</code> class offers constants for  common SQL keywords and static factory methods for creating complex or simple sql elements:</p> <pre><code>use pine3ree\\Db\\Sql;\nuse pine3ree\\Db\\Sql\\Alias;\nuse pine3ree\\Db\\Sql\\Expression;\nuse pine3ree\\Db\\Sql\\Literal;\nuse pine3ree\\Db\\Sql\\Identifier;\nuse pine3ree\\Db\\Sql\\Statement;\n\n// Create Identifier elements: dots are considered identifier separators\n$column = Sql::identifier('category_id'); // sql-string: \"category_id\"\n$column = Sql::identifier('p.category_id'); // sql-string: \"p\".\"category_id\"\n\n// Create sql Alias elements: dots are considered part of the alias expression\n$alias = Sql::alias('t0'); // sql-string: \"t0\"\n$alias = Sql::alias('my.Alias'); // sql-string: \"my.Alias\"\n\n// Create parametric sql Expression elements:\n// substitution parameter markers must be enclosed in curly brackets\n$expr = Sql::expression('(price * {vat_rate})', [\n    'vat_rate' =&gt; 20.0,\n]); // sql-string: (price * :expr1)\n// Using shorter method name `expr`\n// sql-string: CONCAT(:expr1, ' ', \"surname\")\n$expr = Sql::expr('CONCAT({title}, ' ', \"surname\")', ['title' =&gt; 'sir']);\n\n// Create parameter-less sql Literal expression elements:\n// substitution parameter markers must be enclosed in curly brackets\n$literal = Sql::literal('(\"price\" * 20.0)'); // sql-string: (\"price\" * 20.0)\n\n$select = Sql::select(); // returns a Statement\\Select instance\n$insert = Sql::insert(); // returns a Statement\\Insert instance\n$update = Sql::update(); // returns a Statement\\Update instance\n$delete = Sql::delete(); // returns a Statement\\Delete instance\n</code></pre> <p>All the factory methods above can be replaced with constructor calls with the same signature.</p>"},{"location":"sql/elements/#factory-functions","title":"Factory functions","text":"<p>To make code more coincise a few importable functions are provided:</p> <pre><code>use function pine3ree\\Db\\Sql\\alias as ali;\nuse function pine3ree\\Db\\Sql\\expression as xpr;\nuse function pine3ree\\Db\\Sql\\identifier as idn;\nuse function pine3ree\\Db\\Sql\\literal as lit;\n\n$column  = idn('p.category_id');\n$alias   = ali('t0');\n$expr    = xpr('(price * {vat_rate})', ['vat_rate' =&gt; 20.0]);\n$literal = lit('(\"price\" * 20.0)');\n</code></pre>"},{"location":"sql/predicates/","title":"Predicates","text":""},{"location":"sql/predicates/#pine3reedbsqlpredicate-and-predicateset","title":"pine3ree\\Db\\Sql\\Predicate and Predicate\\Set","text":"<p>SQL predicates are parts of an sql-statement normally abstracting search-conditions inside sql clauses like WHERE, HAVING, ON. They usually resolve to a sql boolean value.</p> <p>They can be part of a bigger set (predicate-set) and combined together either with an <code>AND</code> sql logical operator or with an <code>OR</code> sql logical operator. The default predicate combination of a set can be decided when calling its constructor. The default combination is <code>AND</code>.</p> <p>A predicate-set may also be part of a bigger enclosing set. In this case the enclosed set is evaluated first and the result is combined with the other top level predicates. In a compiled sql-statement inner predicate sets are rendered enclosed in parenthesis.</p> <p>The predicate-set abstraction also provides chainable factory methods for creating and adding single predicates and inner sets to itself. These methods are proxied by conditional clause classes that composes a predicate-set as their search-condition. The default logical operator is used unless the factory method is preceeded by either an <code>Predicate\\Set::and()</code> or a <code>Predicate\\Set::or()</code> chainable method call.</p> <p>During sql compilation predicate identifiers are quoted as sql-identifiers. To make them to be quoted as aliases you must provide Alias instances instead of strings.</p> <p>Examples:</p> <pre><code>use pine3ree\\Db\\Sql;\nuse pine3ree\\Db\\Sql\\Predicate;\nuse pine3ree\\Db\\Sql\\Statement\\Select;\nuse function pine3ree\\Db\\Sql\\alias;\n\n// Empty predicate-set with \"AND\" as default logical operator\n$predicateSet = new Predicate\\Set();\n// Add Predicate\\Comparison predicates with equality operator\n$predicateSet-&gt;equal('p.vat_rate', 20.0); // \"p\".\"vat_rate\" = :eq1\n$predicateSet-&gt;eq(alias('tot.Price'), 20.0); // AND \"tot.Price\" = :eq2\n\n$predicateSet = new Predicate\\Set([], Sql::OR); // default logical operator is \"OR\"\n$predicateSet-&gt;lessThan('vat_rate', 20.0);// \"vat_rate\" &lt; :lt1\n$predicateSet-&gt;lt('price', 100.0); // OR \"price\" &lt; :lt2\n// Add a Predicate\\Literal predicate with an expression used as it is\n$predicateSet-&gt;and()-&gt;literal('\"published\" IS TRUE'); // AND \"published\" IS TRUE\n$predicateSet-&gt;or()-&gt;gt('stock', 10); // OR \"stock\" &gt; :gt1\n</code></pre> <p>As a convenience predicate-set methods may also have a shorter and/or equivalent form:</p> <pre><code>use pine3ree\\Db\\Sql\\Predicate;\n\n// Creates a Predicate\\Comparison with operator =\nPredicate\\Set::equal($identifier, $value);\nPredicate\\Set::eq($identifier, $value);\n// Creates a Predicate\\Comparison with operator !=\nPredicate\\Set::notEqual($identifier, $value);\nPredicate\\Set::neq($identifier, $value);\n// Creates a Predicate\\Comparison with operator &lt;&gt;\nPredicate\\Set::ne($identifier, $value);\n// Creates a Predicate\\Comparison with operator &lt;\nPredicate\\Set::lessThan($identifier, $value);\nPredicate\\Set::lt($identifier, $value);\n// Creates a Predicate\\Comparison with operator &lt;=\nPredicate\\Set::lessThanEqual($identifier, $value);\nPredicate\\Set::lte($identifier, $value);\n// Creates a Predicate\\Comparison with operator &gt;=\nPredicate\\Set::greaterThanEqual($identifier, $value);\nPredicate\\Set::gte($identifier, $value);\n// Creates a Predicate\\Comparison with operator &gt;\nPredicate\\Set::greaterThan($identifier, $value);\nPredicate\\Set::gt($identifier, $value);\n\nPredicate\\Set::like($identifier, $value, $escape); // Predicate\\Like\nPredicate\\Set::notLike($identifier, $value, $escape); // Predicate\\NotLike\n\nPredicate\\Set::between($identifier, $min, $max); // Predicate\\Between\nPredicate\\Set::notBetween($identifier, $min, $max); // Predicate\\NotBetween\n\nPredicate\\Set::in($identifier, array|Select $valueList); // Predicate\\In\nPredicate\\Set::notIn($identifier, array|Select $valueList); // Predicate\\NotIn\n\nPredicate\\Set::is($identifier, true|false|null|'UNKNOWN'); // Predicate\\Is\nPredicate\\Set::isNot($identifier, true|false|null|'UNKNOWN'); // Predicate\\IsNot\nPredicate\\Set::isNull($identifier); // Predicate\\IsNull\nPredicate\\Set::isNotNull($identifier); // Predicate\\IsNotNull\nPredicate\\Set::isTrue($identifier); // Predicate\\IsTrue\nPredicate\\Set::isFalse($identifier); // Predicate\\IsFalse\nPredicate\\Set::isUnknown($identifier); // Predicate\\IsUnknown\n\nPredicate\\Set::literal(string $literal); // Predicate\\Literal\nPredicate\\Set::expression(string $expr, array $susbtitutions); // Predicate\\Expression\nPredicate\\Set::expr(string $expr, array $susbtitutions); // Predicate\\Expression\n\nPredicate\\Set::exists($identifier, $operator, Select $select); // Predicate\\Exists\nPredicate\\Set::notExists($identifier, $operator, Select $select); // Predicate\\NotExists\n\nPredicate\\Set::all($identifier, $operator, Select $select); // Predicate\\All\nPredicate\\Set::any($identifier, $operator, Select $select); // Predicate\\Any\nPredicate\\Set::some($identifier, $operator, Select $select); // Predicate\\Some\n</code></pre> <p>Predicate sets initialized with a string will use the string to create a literal predicate:</p> <pre><code>use pine3ree\\Db\\Sql\\Predicate;\n\n// The following set will contain 1 predicate of class Predicate\\Literal\n$predicateSet = new Predicate\\Set('MAX(\"price\") &lt;= 100.0'); // MAX(\"price\") &lt;= 100.0\n</code></pre> <p>Sub sets of predicates may be created using <code>begingGroup()</code> calls:</p> <pre><code>use pine3ree\\Db\\Sql\\Predicate;\n\n$predicateSet = new Predicate\\Set();\n\n// Add predicates\n\n// Begin a sub set\n// The following code will be compiled to (\"price\" &gt; :gt1 OR \"stock\" &gt; :gt2)\n$predicateSet\n    -&gt;beginGroup() // entering the subset scope\n        -&gt;gt('price', 100.0)\n        -&gt;or()\n        -&gt;gt('stock', 42)\n    -&gt;endGroup() // back to the upper-level set scope\n</code></pre> <p>Predicate sets can also be created using array specifications. This is useful when used in sql statement <code>where()</code>, <code>having()</code>, <code>on()</code> method calls.</p> <p>Examples:</p> <pre><code>use pine3ree\\Db\\Sql;\n\n$conditions = [\n    'id IS NOT NULL', // a string is converted to a literal predicate\n    ['price', '&lt;=', 100.0], // identifier, operator, value\n    ['date_created', 'between', '2020-01-01', '2020-12-31'], // identifier, operator, value, extra-value\n    ['name', 'LIKE', 'B%'], // using the 'LIKE' exact keyword\n    ['name', 'like', 'B%'], // using the lowercase alias\n    ['name', Sql::LIKE, 'B%'], // using the Sql::LIKE constant\n    ['name', '~', 'B%'], // using the '~' alias\n    ['name', 'NOT LIKE', 'A%'], // using the 'NOT LIKE' exact keywords\n    ['name', Sql::NOT_LIKE, 'A%'], // using the Sql::NOT_LIKE constant\n    ['name', 'notLike', 'A%'], // using the lowercase 'notLike' alias\n    ['name', '!~', 'A%'], // using the '!~' alias\n    ['category_id', 'in', [11, 22, 33]], // \"category_id\" IN (:in1, :in2, :in3)\n    ['store_id', 'in', [1, 2, null]], // \"store_id\" IN (:in4, :in5) OR \"store_id\" IS NULL\n    'vat_rate' =&gt; 10.0, // identifier =&gt; value implies the equality operator\n    '||' =&gt; [ // creates a group with 'OR' as default logical operator\n        // predicate-specs-1,\n        // predicate-specs-2,\n        //...\n    ],\n    '&amp;&amp;' =&gt; [ // creates a group with 'AND' as default logical operator\n        // predicate-specs-1,\n        // predicate-specs-2,\n        //...,\n    ],\n ];\n\nSql::select('*')-&gt;from('product')-&gt;where($conditions);\n</code></pre> <p>Predicate specifications may use the exact sql operator string either directly or preferably via Sql class constants, or using camelCased versions such as \"notLike\". \"LIKE\" and \"NOT LIKE\" can be specified using <code>~</code> and <code>!~</code> convenience aliases respectively.</p>"},{"location":"sql/statements/","title":"Statements","text":""},{"location":"sql/statements/#pine3reedbsqlstatement","title":"pine3ree\\Db\\Sql\\Statement","text":"<p>SQL statement classes abstracts full sql statements with named placeholder markers in place of the actual parameter values. They are composed of simpler elements like identifiers, aliases, expressions, predicates and clauses. Statement are actually sql-statement builders providing methods for adding the innser elements they are composed of.</p> <p>Supported statements are <code>Select</code> for DQL, and <code>Insert</code>, <code>Update</code>, <code>Delete</code> for DML, reflecting the previously examined database command classes. The sql-building methods used in a command instance are proxies to corresponding methods of composed sql-statement instance.</p>"}]}