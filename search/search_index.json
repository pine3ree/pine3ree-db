{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pine3ree-db","text":"<p><code>pine3ree\\Db</code> is a small database abstraction layer on top of the <code>\\PDO</code> library.</p> <p>It provides a simple sql builder and convenience methods for common CRUD opeations.</p> <p>The DBAL instance consists of a simple PDO connection wrapper that can either use an existing connection or instantiate a new lazy pdo connection on demand.</p> <p>Basic database operations for retrieving, inserting, updating and deleting rows from/into a given database table leverage a set of database Command classes, which in turn compose the database connection itself and a corresponding sql abstraction statement object.</p> <p>The sql-command building operations are forwarded to the composed sql abstraction layer object, while the sql statement preparation, parameter binding and command execution are performed by the composed DBAL instance.</p>"},{"location":"#installation","title":"Installation","text":"<p>pine3ree-db DBAL requires php &gt;= 7.4 and can be installed via composer</p> <pre><code>$ composer require pine3ree/pine3ree-db\n</code></pre> <p>The package does not provide any stable version yet, so <code>\"minimum-stability\": \"dev\"</code> setting is required in your <code>composer.json</code> file.</p>"},{"location":"#features","title":"Features","text":"<p>The library's code is splitted into two main sections/namespaces:</p> <ul> <li> <p>a <code>Sql</code> section in which sql generation of full statements or smaller fragments   is abstracted</p> </li> <li> <p>a <code>Command</code> section which offers objects that actually send the sql statements   to the database server by means ot the composed connection and retrieve the results of   such operations such as row/record set for DQL statements and of number of   affected rows for DML statements.</p> </li> </ul>"},{"location":"db/","title":"pine3ree\\Db","text":""},{"location":"db/#note","title":"Note:","text":"<p>Unless otherwise stated the compiled sql-strings identifiers and aliases in the examples will be quoted according to the default <code>Ansi</code> driver, i.e. using double quotes <code>\"</code>.</p>"},{"location":"db/#quick-start","title":"Quick start","text":"<pre><code>use pine3ree\\Db;\nuse pine3ree\\Db\\Factory\\DbFactory;\nuse PDO;\n\n// 1. Create a dbal instance using an existing PDO connection\n$pdo = new PDO('my-db-dsn', 'my-db-username', 'my-db-password');\n$db = new Db($pdo);\n\n// 2. Create a dbal instance using pdo configuration: the PDO connection is created on demand\n$db = new Db('my-db-dsn', 'my-db-username', 'my-db-password');\n\n// 3. Create a dbal instance using a factory: the provided factory fetch a configuration\n// array from a psr-container under the `config` id/alias with specific database\n// configuration subarray under either a `db` or `pdo` key.\n$factory = new DbFactory();\n$db = $factory($container);\n\n// 4. Create a dbal instance using a factory method directly from database/pdo\n// configuration array:\n$db = DbFactory::create([\n    'driver'   =&gt; 'mysql',\n    'host'     =&gt; 'localhost',\n    'port'     =&gt; 3306,\n    'database' =&gt; 'testdb',\n    'username' =&gt; 'testuser',\n    'password' =&gt; 'secret',\n    'charset'  =&gt; 'utf8',\n]);\n\n// Simple proxy method to \\PDO::query() returning a traversable PDOStatement or\n// false if query execution fails\n$stmt = $db-&gt;query('SELECT * FROM product WHERE price &lt; 100.0 AND id &lt; 100');\n\n// Simple proxy method to \\PDO::exec(), returns the number of affected rows, or\n// false if execution fails\n$affected = $db-&gt;exec('UPDATE product SET published = FALSE WHERE stock &lt;= 0');\n</code></pre> <p>Other examples:</p> <pre><code>// Fetch all rows from the \"product\" table\n// fetchAll(string $table, $where = null, $order = null, int $limit = null, int $offset = null): array\n$products = $db-&gt;fetchAll('product');\n\n// Fetch the product row with column id = 42\n// fetchOneBy(string $table, string $column, $value, $order = null): ?array\n$product = $db-&gt;fetchOneBy('product', 'id', 42);\n\n// Same row using `fetchOne()` with condition in array-format\n// fetchOne(string $table, $where = null, $order = null): ?array\n$product = $db-&gt;fetchOne('product', ['id' =&gt; 42]);\n\n$fiftyExpensiveProducts = $db-&gt;fetchAll(\n    'product', [ // conditions array start\n        ['price', '&gt;', 1000.00], // 1 conditions in array-format\n    ], // conditions array end\n    [\n        'price' =&gt; 'ASC',\n    ],\n    50\n);\n\n$tenMostExpensiveProducts = $db-&gt;fetchAll('product', null, ['price' =&gt; 'DESC'], 10);\n\n$mostExpensiveProduct = $db-&gt;fetchOne('product', null, ['price' =&gt; 'DESC']);\n</code></pre>"},{"location":"db/#constructor-arguments","title":"Constructor arguments","text":"<p><code>pine3ree\\Db</code> supports the same constructor arguments as the <code>\\PDO</code> class.</p> <p>It also supports an extra argument, an optional custom PDO subclass to use in lazy connection instances.</p> <pre><code>class Db\n{\n   /**\n     * @param string|PDO $dsn_or_pdo A valid pdo dsn string or an existing pdo connection instance\n     * @param string|null $username PDO connection username\n     * @param string|null $password PDO connection password\n     * @param array|null $options PDO connection options\n     * @param string|null $pdoClass An optional PDO subclass to use when creating a new connection\n     */\n    public function __construct(\n        $dsn_or_pdo,\n        string $username = null,\n        string $password = null,\n        array $options = null,\n        string $pdoClass = null\n    ) {\n}\n//...\n</code></pre> <p>The first argument can also be an existing PDO instance itself, that will be used as the composed pdo connection.</p>"},{"location":"db/#factory-configuration-parameters","title":"Factory configuration parameters","text":"<p>Factory configuration retrieved from the container should return an array like the one below:</p> <pre><code>// file config.php\nreturn [\n    // full dsn specification\n    'db' =&gt; [ // alt key: 'pdo' =&gt; [...]\n        'dns'      =&gt; 'mysql:dbname=testdb;host=localhost;port=3306;charset=utf8',\n        'username' =&gt; 'testuser', // alt key: 'user'\n        'password' =&gt; 'secret', // alt key: 'passwd' or 'pass'\n    ],\n    // ...or single parameters specs\n    'db' =&gt; [\n        'driver'   =&gt; 'mysql',\n        'dbname'   =&gt; 'testdb', // alt key: 'database'\n        'host'     =&gt; 'localhost', // alt key: 'hostname'\n        'port'     =&gt; 3306,\n        'charset'  =&gt; 'utf8',\n        'username' =&gt; 'testuser', // alt key: 'user'\n        'password' =&gt; 'secret', // alt key: 'passwd' or 'pass'\n        'options'  =&gt; [\n            // pdo-options array\n        ]\n    ],\n];\n</code></pre> <p>The database configuration subkeys depend on the db driver used and must be all in snake_case format. Please check the pdo driver page https://www.php.net/manual/en/pdo.drivers.php for more information.</p> <p>The factory will attempt to build a valid pdo DSN with the provided configuration parameters.</p> <p>Supported drivers are <code>mysql</code>, <code>pgsql</code>, <code>sqlite</code>, <code>sqlsrv</code> and <code>oci</code>.</p>"},{"location":"db/#crud-commands","title":"CRUD commands","text":"<p>To start building a crud databse command you can use the following methods:</p> <pre><code>$select = $db-&gt;select(); // returns a pine3ree\\Db\\Command\\Select instance\n$insert = $db-&gt;insert(); // returns a pine3ree\\Db\\Command\\Insert instance\n$update = $db-&gt;update(); // returns a pine3ree\\Db\\Command\\Update instance\n$delete = $db-&gt;delete(); // returns a pine3ree\\Db\\Command\\Delete instance\n</code></pre> <p>Database command instances provide a fluent interface for building sql statement. The sql build is actually perfomed by the composed sql-statement (<code>pine3ree\\Db\\Sql\\Statement</code>) instance with the help of the sql-driver (<code>pine3ree\\Sql\\DriverInterface</code>) created for the current connection.</p> <p>The corresponding sql-statement objects ca be created with the following <code>pine3ree\\Db\\Sql</code> helper class static methods:</p> <pre><code>$select = Sql::select(); // returns a pine3ree\\Db\\Sql\\Statement\\Select instance\n$insert = Sql::insert(); // returns a pine3ree\\Db\\Sql\\Statement\\Insert instance\n$update = Sql::update(); // returns a pine3ree\\Db\\Sql\\Statement\\Update instance\n$delete = Sql::delete(); // returns a pine3ree\\Db\\Sql\\Statement\\Delete instance\n</code></pre> <p>The <code>Sql\\Statement</code> classes, as any other <code>Sql\\Element</code> class, provide a <code>getSQL()</code> method which compiles the sql string for the given sql-driver argument or the default <code>Ansi</code> driver. The sql-drivers provide identifier quoting and other sql transformations according to the underlying platform. The <code>getSQL()</code> method also collects user-provided parameter values along with their pdo-param types and sets named markers in their place into the sql string. The paramater collector can be retrieved by <code>getParams()</code> either from the sql-statement object or the wrapping command. A internal collector will be created only if not passed-in as the 2nd argument of the <code>getSQL()</code> call.</p> <p>All database command classes implement the <code>execute()</code> method.</p> <ul> <li>For writer-DML-commands (Insert|Update|Delete) <code>execute()</code> will call the writer   method <code>Writer::exec()</code> and will return either the number of rows affected or   <code>false</code> on failure.</li> <li>For reader-DQL-commands (Select) <code>execute()</code> will call the reader method   <code>Reader::query()</code> and will return either a traversable <code>\\PDOStatement</code>   result-set object or <code>false</code> on failure.</li> </ul>"},{"location":"db/#dbselect","title":"Db::select()","text":"<p>Create a <code>pine3ree\\Db\\Command\\Select</code> reader command instance</p> <pre><code>use pine3ree\\Db;\nuse pine3ree\\Db\\Sql;\n\n/** @var Db $db */\n\n$select = $db-&gt;select(); // create a generic empty Select command instance\n\n// SELECT * FROM \"product\"\n$select = $db-&gt;select('*', 'product');\n$select = $db-&gt;select('*')-&gt;from('product');\n$select = $db-&gt;select(null, 'product');\n$select = $db-&gt;select()-&gt;from('product');\n\n// Use table alias: SELECT * FROM \"product\" \"p\"\n$select = $db-&gt;select('*', 'product', 'p');\n$select = $db-&gt;select('*')-&gt;from('product', 'p');\n$select = $db-&gt;select()-&gt;from('product', 'p');\n\n // SELECT \"p\".\"price\", \"p\".\"vat_rate\" AS \"vatRate\" FROM \"product\" \"p\"\n$select = $db-&gt;select(['price', 'vatRate' =&gt; 'vat_rate'])-&gt;from('product', 'p');\n\n// Add where condition LessThanEqual and order-by clause\n$select-&gt;where-&gt;lte('price', 1000.0); // WHERE \"price\" &lt;= :lte1 (named parameter marker)\n\n// ORDER BY \"p\".\"price\" ASC\n$select-&gt;orderBy('p.price', 'ASC');\n$select-&gt;orderBy('p.price', Sql::ASC);\n\n// ORDER BY \"price\" ASC, \"vat_rate\" DESC\n$select-&gt;orderBy([\n    'price' =&gt; Sql::ASC, // or just 'price' =&gt; 'ASC'\n    'vat_rate' =&gt; Sql::DESC, // or just 'vat_rate' =&gt; 'DESC'\n]);\n\n$stmt = $select-&gt;execute(); // or $select-&gt;query(), returns a \\PDOStatement instance or FALSE\n\n// SELECT\n//    \"category_id\" AS \"catId\",\n//    COUNT(*) AS \"numProducts\"\n// FROM \"product\" WHERE \"price\" &gt; :gt1\n// GROUP BY \"category_id\"\n// HAVING \"numProducts\" &gt;= :gte1\n$select = $db-&gt;select()\n    -&gt;column('category_id', 'catId')\n    -&gt;count('*', 'numProducts')\n    -&gt;from('product');\n    -&gt;where-&gt;gte('price', 10.0);\n// using $select-&gt;where or $select-&gt;having changes the scope and the fluent interface\n// method chain is broken\n\n// Add a GROUP BY\n// GROUP BY \"category_id\" HAVING \"numProducts\" &lt; :lte1\n$select-&gt;groupBy('category_id')\n    -&gt;having-&gt;lte('numProducts', 5);\n\n// SELECT MIN(\"price\") FROM \"product\" GROUP BY \"category_id\"\n$select = $db-&gt;select()-&gt;min('price')-&gt;from('product')-&gt;groupBy('category_id');\n</code></pre>"},{"location":"db/#dbinsert","title":"Db::insert()","text":"<p>Create and optionally execute an <code>pine3ree\\Db\\Command\\Insert</code> writer command instance.</p> <pre><code>// INSERT INTO \"product\" (\"name\", \"price\") VALUES (:val1, :val2)\n$insert = $db-&gt;insert()\n    -&gt;into('product')\n    -&gt;row([\n        'name' =&gt; 'product-1',\n        'price' =&gt; 100.00,\n]);\n\n// equivalent to\n$insert = $db-&gt;insert()\n    -&gt;into('product')\n    -&gt;columns(['name', 'price'])\n    -&gt;values(['product-1', 100.00]);\n\n$result = $insert-&gt;execute() // or $insert-&gt;exec(), returns TRUE or FALSE for single row insert\n</code></pre> <p>Insert and execute shortcut call, when both arguments (<code>$table</code> and <code>$row</code>/<code>$rows</code>) are provided:</p> <pre><code>$result = $db-&gt;insert('product', [\n    'name' =&gt; 'product-111',\n    'price' =&gt; 111.11,\n]); // returns TRUE or FALSE for single insert\n\n// get the last generated value if the insert is successful\n$id = $result ? $db-&gt;lastInsertId() : null;\n</code></pre> <p>Insert many rows:</p> <pre><code>// INSERT INTO \"product\" (\"name\", \"price\") VALUES (:val1, :val2), (:val3, :val4)\n$num_inserted = $db-&gt;insert('product', [\n    [\n        'name' =&gt; 'product-111',\n        'price' =&gt; 111.11,\n    ],\n    [\n        'name' =&gt; 'product-222',\n        'price' =&gt; 222.22,\n    ],\n]); // returns integer or FALSE for multi-rows inserts\n\n// equivalent to\n$num_inserted = $db-&gt;insert()\n    -&gt;into('product')\n    -&gt;rows([\n        [\n            'name' =&gt; 'product-111',\n            'price' =&gt; 111.11,\n        ],\n        [\n            'name' =&gt; 'product-222',\n            'price' =&gt; 222.22,\n        ],\n    ])-&gt;execute(); // or exec()\n\n// and to\n$num_inserted = $db-&gt;insert()\n    -&gt;into('product')\n    -&gt;columns(['name', 'price'])\n    -&gt;values([\n        'product-111',\n        111.11,\n    ])\n    -&gt;values([\n        'product-222',\n        222.22,\n    ], true) // The TRUE argument add values to existing values instead of replacing them\n    -&gt;execute(); // or exec()\n\n// and to\n$num_inserted = $db-&gt;insert()\n    -&gt;into('product')\n    -&gt;columns(['name', 'price'])\n    -&gt;multipleValues([\n        [\n            'product-111',\n            111.11,\n        ],\n        [\n            'product-222',\n            222.22,\n        ],\n    ])-&gt;execute();\n</code></pre> <p>By default <code>Insert::values(array $values, bool $add = false)</code> and <code>Insert::row(array $row, bool $add = false)</code> will set insert values removing any previously accumulated set of values. </p> <p>The opposite happens for <code>Insert::rows(array $rows, bool $add = true)</code> and <code>Insert::multipleValues(array $values, bool $add = true)</code>. These methods calls will add the new rows/values provided to the existing ones.</p> <pre><code>$insert = $db-&gt;insert('product');\n\n$insert-&gt;row(['price' =&gt; 111.11, 'stock' =&gt; 111]); // Adds 1 set of values\n$insert-&gt;row(['price' =&gt; 222.22, 'stock' =&gt; 222], true); // Adds 1 set of values\n// Columns \"price\" and \"stock\" are alredy specified by previuous row() calls\n$insert-&gt;values([333.33, 333], true); // Adds 1 set of values\n\n$insert-&gt;execute(); // This will try to insert 3 rows\n\n$insert-&gt;values([444.44, 444]); // Adds another set of values\n$insert-&gt;execute(); // This will try to insert 4 rows\n\n // Define the insert values after removing the old ones\n$insert-&gt;row(['price' =&gt; 555.55, 'stock' =&gt; 555], true);\n$insert-&gt;execute(); // This will try to insert 1 row\n</code></pre>"},{"location":"db/#dbupdate","title":"Db::update()","text":"<p>The <code>pine3ree\\Db\\Command\\Update</code> command abstracts an INSERT operation</p> <p>A non empty condition/predicate is required, otherwise an exception is thrown.</p> <p>Examples:</p> <pre><code>// UPDATE \"product\" SET \"published\" = :set1 WHERE stock &gt; 0\n$update = $db-&gt;update()-&gt;table('product')-&gt;set('published', true)-&gt;where('stock &gt; 0');\n$update = $db-&gt;update('product')-&gt;set('published', true)-&gt;where('stock &gt; 0');\n$affected = $update-&gt;execute(); // or exec()\n\n// Immediate command execution\n// UPDATE \"product\" SET \"published\" = :set1 WHERE TRUE, we use the condition \"TRUE\" to update all records\n$affected = $db-&gt;update('product', ['published' =&gt; true], 'TRUE');\n</code></pre>"},{"location":"db/#dbdelete","title":"Db::delete()","text":"<p>The <code>pine3ree\\Db\\Command\\Delete</code> command abstracts a SQL DELETE operation</p> <p>A non empty condition/predicate is required, otherwise an exception is thrown.</p> <p>Examples:</p> <pre><code>// DELETE FROM \"product\" WHERE stock &lt;= 0\n$delete = $db-&gt;delete()-&gt;from('product')-&gt;where('stock &lt;= 0');\n$delete = $db-&gt;delete('product')-&gt;where('stock &lt;= 0');\n$num_deleted = $delete-&gt;execute(); // or exec()\n\n// immediate command execution\n// DELETE FROM \"product\" WHERE stock &lt;= 0\n$num_deleted = $db-&gt;delete('product', 'stock &lt;= 0');\n</code></pre>"},{"location":"db/#sql-driver-proxy-helper-methods","title":"Sql driver proxy helper methods","text":"<p>The following methods are simple proxies to methods implemented in the <code>pine3ree\\Db\\Sql\\DriverInterface</code> class of the current dbal's sql-driver instance.</p> <ul> <li><code>Db::quoteIdentifier(string $identifier)</code> quotes given column/table SQL identifier</li> <li><code>Db::quoteAlias(string $alias)</code> quotes given SQL aliase</li> <li><code>Db::quoteValue(null|scalar $value)</code> perform type-casting and quotes - when required - the given value</li> </ul>"},{"location":"sql/clauses/","title":"Clauses","text":"<p>The abstract class <code>pine3ree\\Db\\Sql\\Clause</code> is the base class for implementations that abstract common SQL clauses such as the <code>JOIN</code> clause and the conditional clauses <code>WHERE</code>, <code>HAVING</code> and <code>ON</code>.</p>"},{"location":"sql/clauses/#the-where-having-and-on-conditional-clauses","title":"The Where, Having and On conditional clauses","text":"<p>A conditional clause wraps a search condition object as an instance of <code>Predicate\\Set</code> It also provides proxy methods to all the condition building methods of a predicate-set. After the first call of any of such methods we are brought into the context of the composed predicate-set.</p> <pre><code>\nuse pine3ree\\Db\\Sql\\Params;\nuse pine3ree\\Db\\Sql\\Predicate;\n\nConditionalClause::getSearchCondition(): Predicate\\Set;\nConditionalClause::isEmpty(): bool\nConditionalClause::hasParams(): bool\nConditionalClause::getParams(): ?Params\nConditionalClause::getSQL(DriverInterface $driver = null, Params $params = null): string\n/**\n * @param Predicate|string|array $predicate A Predicate|Predicate\\Set instance\n *      or a specs-array [identifier, operator, value] or [identifier =&gt; value]\n */\nConditionalClause::addPredicate($predicate): Predicate\\Set;\nConditionalClause::literal(string $literal): Predicate\\Set;\nConditionalClause::expression(string $expression, array $substitutions = []): Predicate\\Set;\nConditionalClause::expr(string $expression, array $substitutions = []): Predicate\\Set;\nConditionalClause::all($identifier, string $operator, Select $select): Predicate\\Set;\nConditionalClause::any($identifier, string $operator, Select $select): Predicate\\Set;\nConditionalClause::some($identifier, string $operator, Select $select): Predicate\\Set;\nConditionalClause::between($identifier, $min_value, $max_value): Predicate\\Set;\nConditionalClause::notBetween($identifier, $min_value, $max_value): Predicate\\Set;\nConditionalClause::exists(Select $select): Predicate\\Set;\nConditionalClause::notExists(Select $select): Predicate\\Set;\nConditionalClause::in($identifier, $valueList): Predicate\\Set;\nConditionalClause::notIn($identifier, $valueList): Predicate\\Set;\nConditionalClause::is($identifier, $value): Predicate\\Set;\nConditionalClause::isNot($identifier, $value): Predicate\\Set;\nConditionalClause::isNull($identifier): Predicate\\Set;\nConditionalClause::isNotNull($identifier): Predicate\\Set;\nConditionalClause::isTrue($identifier): Predicate\\Set;\nConditionalClause::isFalse($identifier): Predicate\\Set;\nConditionalClause::isUnknown($identifier): Predicate\\Set;\nConditionalClause::isNotUnknown($identifier): Predicate\\Set;\nConditionalClause::like($identifier, $pattern, string $escape = null): Predicate\\Set;\nConditionalClause::notLike($identifier, $pattern, string $escape = null): Predicate\\Set;\nConditionalClause::equal($identifier, $value): Predicate\\Set;\nConditionalClause::eq($identifier, $value): Predicate\\Set;\nConditionalClause::notEqual($identifier, $value): Predicate\\Set;\nConditionalClause::neq($identifier, $value): Predicate\\Set;\nConditionalClause::ne($identifier, $value): Predicate\\Set;\nConditionalClause::lessThan($identifier, $value): Predicate\\Set;\nConditionalClause::lt($identifier, $value): Predicate\\Set;\nConditionalClause::lessThanEqual($identifier, $value): Predicate\\Set;\nConditionalClause::lte($identifier, $value): Predicate\\Set;\nConditionalClause::greaterThanEqual($identifier, $value): Predicate\\Set;\nConditionalClause::gte($identifier, $value): Predicate\\Set;\nConditionalClause::greaterThan($identifier, $value): Predicate\\Set;\nConditionalClause::gt($identifier, $value): Predicate\\Set;\nConditionalClause::and(): Predicate\\Set;\nConditionalClause::or(): Predicate\\Set;\nConditionalClause::beginGroup(string $defaultLogicalOperator = Sql::AND): Predicate\\Set;\n\n</code></pre> <p>An endGroup() method is not provided as we call it from the search-condition <code>Predicate\\Set</code> context</p> <p>Examples:</p> <pre><code>\nuse pine3ree\\Db\\Sql;\nuse pine3ree\\Db\\Sql\\Clause\\Where;\nuse pine3ree\\Db\\Sql\\Predicate;\nuse pine3ree\\Db\\Sql\\Statement\\Select;\n\n$date = '2023-10-07';\n\n$select = Sql::select();\n$select\n    -&gt;from('tax_rate', 'tr')\n    -&gt;where // changed context to the composed Where instance\n        -&gt;lte('tr.date_min', $date) // changed context to the composed Predicate\\Set instance\n        -&gt;and()\n        -&gt;beginGroup() // changed context to the nested Predicate\\Set instance\n            -&gt;equal('tr.date_max', '0000-00-00')\n            -&gt;or()\n            -&gt;gte('tr.date_max', $date)\n        -&gt;endGroup(); // changed context back to the Where::$searchCondition Predicate\\Set instance\n\n// SELECT \"tr\".* FROM \"tax_rate\" \"tr\" WHERE \"tr\".\"date_min\" &lt;= :lte1 AND (\"tr\".\"date_max\" = :eq1 OR \"tr\".\"date_max\" &gt;= :gte1)\n\n$select = Sql::select();\n$select\n    -&gt;columns([\n        'id',\n        'name',\n        'originalPrice' =&gt; 'price',\n    ])\n    -&gt;column(Sql::literal('(p.price - p.discount)'), 'discountedPrice')\n    -&gt;from('product', 'p')\n    -&gt;where\n        -&gt;gt('discount', 0.0)\n    -&gt;top() // Back to the Select instance, we could have called -&gt;up()-&gt;up(), or -&gt;closest(Select::class)\n    -&gt;having\n        -&gt;lte('discountedPrice', 100.00);\n\n// SELECT \"p\".\"id\", \"p\".\"name\", \"p\".\"price\" AS \"originalPrice\", (\"p\".price - \"p\".discount) AS \"discountedPrice\"\n// FROM \"product\" \"p\"\n// WHERE \"discount\" &gt; :gt1\n// HAVING \"discountedPrice\" &lt;= :lte1\n</code></pre>"},{"location":"sql/clauses/#the-join-clause","title":"The Join clause","text":"<p>The class <code>pine3ree\\Db\\Sql\\Clause\\Join</code> abstract the SQL JOIN clause. A Join instance is created with at least 2 parameters:</p> <ul> <li>the join type ('', 'INNER', 'CROSS', 'LEFT', 'RIGHT', 'STRAIGHT', 'NATURAL',   'NATURAL LEFT', 'NATURAL RIGHT' - <code>Sql::JOIN_*</code> constants ara available)</li> <li>the joined table name</li> </ul> <p>and most commonly with the following optional parameters</p> <ul> <li>the joined table alias</li> <li>the join specification in the form of a sql literal predicate rendered as the    wrapped string, a sql identifier that is automatically wrapped in a   <code>USING(\"identifier\")</code> clause, an <code>On</code> clause or conditions in various form   (strings, arrays, predicates, predicate-sets, ..) the will be used to build   an <code>On</code> conditional-clause instance</li> </ul> <p>Examples:</p> <pre><code>\nuse pine3ree\\Db\\Sql;\nuse pine3ree\\Db\\Sql\\Clause\\Join;\nuse pine3ree\\Db\\Sql\\Predicate;\nuse pine3ree\\Db\\Sql\\Statement\\Select;\n\n$select = new Select(); // or $select = Sql::select()\n\n$select\n    -&gt;columns([\n        'title',\n        'summary',\n        'date',\n        'author' =&gt; 'u.name', // key:alias, value: column\n    ])\n    -&gt;from('post', 'p')\n    -&gt;addJoin(new Join(\n        Sql::JOIN_LEFT, // or just \"LEFT\",\n        'user',\n        'u',\n        'u.id = p.user_id' // Will be used as a literal predicate for the On clause\n    ));\n\n// The resulting sql-string is split into two lines to improve readability\n//\n// SELECT \"p\".\"title\", \"p\".\"summary\", \"p\".\"date\", \"u\".\"name\" AS \"author\" FROM \"post\" \"p\"\n// LEFT JOIN \"user\" \"u\" ON (\"u\".id = \"p\".user_id)\n\n// If using a literal predicate then \"ON\" sql keyword must be included manually, i.e:\nnew Predicate\\Literal('ON u.id = p.user_id')\n</code></pre> <p>You will usually call join select method intead of programmatically creating new <code>Join instances</code></p> <pre><code>\nuse pine3ree\\Db\\Sql;\nuse pine3ree\\Db\\Sql\\Clause\\Join;\nuse pine3ree\\Db\\Sql\\Statement\\Select;\n\n$select = Sql::select();\n\n$select\n    -&gt;columns([\n        '*',\n        'author' =&gt; 'u.name',\n    ])\n    -&gt;from('post', 'p')\n    -&gt;leftJoin('user', 'u', [ // conditions array used to build the On clause\n        'u.id = p.user_id', // literal string\n        'u.enabled' =&gt; true, // equality condition in key =&gt; value form\n    ]);\n\n// SELECT \"p\".*, \"u\".\"name\" AS \"author\" FROM \"post\" \"p\"\n// LEFT JOIN \"user\" \"u\" ON (\"u\".id = \"p\".user_id AND \"u\".\"enabled\" = :eq1)\n</code></pre> <p>The sql <code>Select</code> statement class provides the following utility methods for sql-joins:</p> <pre><code>Select::addJoin(Join $join): self;\n\n/**\n * Common signature\n *\n * @param string $table The joined table name\n * @param string $alias The joined table alias\n * @param On|Predicate|Predicate\\Set|array|string|Literal|Identifier|null $specification\n * @return $this Fluent interface\n */\n\nSelect::innerJoin(string $table, string $alias, $specification = null): self;\nSelect::leftJoin(string $table, string $alias, $specification = null): self;\nSelect::rightJoin(string $table, string $alias, $specification = null): self;\nSelect::naturalJoin(string $table, string $alias, $specification = null): self;\nSelect::naturalLeftJoin(string $table, string $alias, $specification = null): self;\nSelect::naturalRightJoin(string $table, string $alias, $specification = null): self;\nSelect::crossJoin(string $table, string $alias, $specification = null): self;\nSelect::straightJoin(string $table, string $alias, $specification = null): self;\n\n</code></pre>"},{"location":"sql/drivers/","title":"Drivers","text":""},{"location":"sql/drivers/#pine3reedbsqldriverinterface","title":"pine3ree\\Db\\Sql\\DriverInterface","text":""},{"location":"sql/elements/","title":"Elements","text":""},{"location":"sql/elements/#pine3reedbsqlelementinterface","title":"pine3ree\\Db\\Sql\\ElementInterface","text":"<p>A sql element represents full sql statements or just part of it such as identifiers, aliases, predicate, clauses, etc...</p> <p>It provides a <code>getSQL(DriverInterface $driver = null, Params $params = null)</code> method that returns the compiled SQL-string for the elements itself with the help of the given driver and collects parameter values and types to be used when the sql-statements are being prepared to be sent to the database server.</p> <p>Sql elements are also automatically organized in hierarchies when calling many elements' interface methods that add inner elements. An element can only have one and the same parent, but a cloned element has no parent assigned to it. When an element is cloned, any child element is cloned as well and then assigned to it.</p> <p>Any changes to inner elements must invalidate any compiled sql-string that has been cached.</p> <p>The sql Element interface provides the following methods:</p> <pre><code>\n// Return the compiled sql using the specified or the default ansi driver and\n// accumulate parameters and relative markers using the provided parameter\n// accumulator or an internal accumulator\nElementInterface::getSQL(DriverInterface $driver = null, Params $params = null): string;\n// Returns TRUE if the internal parameter accumulator exists and is not empty\nElementInterface::hasParams(): bool;\n// Returns the internal parameter accumulator, if any\nElementInterface::getParams(): ?Params;\n// Returns the parent element, if any\nElementInterface::getParent(): ?self;\n</code></pre>"},{"location":"sql/elements/#pine3reedbsql","title":"pine3ree\\Db\\Sql","text":"<p>The <code>Db\\Sql</code> class offers constants for  common SQL keywords and static factory methods for creating complex or simple sql elements:</p> <pre><code>use pine3ree\\Db\\Sql;\nuse pine3ree\\Db\\Sql\\Alias;\nuse pine3ree\\Db\\Sql\\Expression;\nuse pine3ree\\Db\\Sql\\Literal;\nuse pine3ree\\Db\\Sql\\Identifier;\nuse pine3ree\\Db\\Sql\\Statement;\n\n// Create Identifier elements: dots are considered identifier separators\n$column = Sql::identifier('category_id'); // sql-string: \"category_id\"\n$column = Sql::identifier('p.category_id'); // sql-string: \"p\".\"category_id\"\n\n// Create sql Alias elements: dots are considered part of the alias expression\n$alias = Sql::alias('t0'); // sql-string: \"t0\"\n$alias = Sql::alias('my.Alias'); // sql-string: \"my.Alias\"\n\n// Create parametric sql Expression elements:\n// substitution parameter markers must be enclosed in curly brackets\n$expr = Sql::expression('(price * {vat_rate})', [\n    'vat_rate' =&gt; 20.0,\n]); // sql-string: (price * :expr1)\n// Using shorter method name `expr`\n// sql-string: CONCAT(:expr1, ' ', \"surname\")\n$expr = Sql::expr('CONCAT({title}, ' ', \"surname\")', ['title' =&gt; 'sir']);\n\n// Create parameter-less sql Literal expression elements:\n// substitution parameter markers must be enclosed in curly brackets\n$literal = Sql::literal('(\"price\" * 20.0)'); // sql-string: (\"price\" * 20.0)\n\n$select = Sql::select(); // returns a Statement\\Select instance\n$insert = Sql::insert(); // returns a Statement\\Insert instance\n$update = Sql::update(); // returns a Statement\\Update instance\n$delete = Sql::delete(); // returns a Statement\\Delete instance\n</code></pre> <p>All the factory methods above can be replaced with constructor calls with the same signature.</p>"},{"location":"sql/elements/#factory-functions","title":"Factory functions","text":"<p>To make code more coincise a few importable functions are provided:</p> <pre><code>use function pine3ree\\Db\\Sql\\alias as ali;\nuse function pine3ree\\Db\\Sql\\expression as xpr;\nuse function pine3ree\\Db\\Sql\\identifier as idn;\nuse function pine3ree\\Db\\Sql\\literal as lit;\n\n$column  = idn('p.category_id');\n$alias   = ali('t0');\n$expr    = xpr('(price * {vat_rate})', ['vat_rate' =&gt; 20.0]);\n$literal = lit('(\"price\" * 20.0)');\n</code></pre>"},{"location":"sql/predicates/","title":"Predicates","text":""},{"location":"sql/predicates/#pine3reedbsqlpredicate-and-predicateset","title":"pine3ree\\Db\\Sql\\Predicate and Predicate\\Set","text":"<p>SQL predicates are parts of an sql-statement normally abstracting search-conditions inside sql clauses like WHERE, HAVING, ON. They usually resolve to a sql boolean value.</p> <p>They can be part of a bigger set (predicate-set) and combined together either with an <code>AND</code> sql logical operator or with an <code>OR</code> sql logical operator. The default predicate combination of a set can be decided when calling its constructor. The default combination is <code>AND</code>.</p> <p>A predicate-set may also be part of a bigger enclosing set. In this case the enclosed set is evaluated first and the result is combined with the other top level predicates. In a compiled sql-statement inner predicate sets are rendered enclosed in parenthesis.</p> <p>The predicate-set abstraction also provides chainable factory methods for creating and adding single predicates and inner sets to itself. These methods are proxied by conditional clause classes that composes a predicate-set as their search-condition. The default logical operator is used unless the factory method is preceeded by either an <code>Predicate\\Set::and()</code> or a <code>Predicate\\Set::or()</code> chainable method call.</p> <p>During sql compilation predicate identifiers are quoted as sql-identifiers. To make them to be quoted as aliases you must provide Alias instances instead of strings.</p> <p>Examples:</p> <pre><code>use pine3ree\\Db\\Sql;\nuse pine3ree\\Db\\Sql\\Predicate;\nuse pine3ree\\Db\\Sql\\Statement\\Select;\nuse function pine3ree\\Db\\Sql\\alias;\n\n// Empty predicate-set with \"AND\" as default logical operator\n$predicateSet = new Predicate\\Set();\n// Add Predicate\\Comparison predicates with equality operator\n$predicateSet-&gt;equal('p.vat_rate', 20.0); // \"p\".\"vat_rate\" = :eq1\n$predicateSet-&gt;eq(alias('tot.Price'), 20.0); // AND \"tot.Price\" = :eq2\n\n$predicateSet = new Predicate\\Set([], Sql::OR); // default logical operator is \"OR\"\n$predicateSet-&gt;lessThan('vat_rate', 20.0);// \"vat_rate\" &lt; :lt1\n$predicateSet-&gt;lt('price', 100.0); // OR \"price\" &lt; :lt2\n// Add a Predicate\\Literal predicate with an expression used as it is\n$predicateSet-&gt;and()-&gt;literal('\"published\" IS TRUE'); // AND \"published\" IS TRUE\n$predicateSet-&gt;or()-&gt;gt('stock', 10); // OR \"stock\" &gt; :gt1\n</code></pre> <p>As a convenience predicate-set methods may also have a shorter and/or equivalent form:</p> <pre><code>use pine3ree\\Db\\Sql\\Predicate;\n\n// Creates a Predicate\\Comparison with operator =\nPredicate\\Set::equal($identifier, $value);\nPredicate\\Set::eq($identifier, $value);\n// Creates a Predicate\\Comparison with operator !=\nPredicate\\Set::notEqual($identifier, $value);\nPredicate\\Set::neq($identifier, $value);\n// Creates a Predicate\\Comparison with operator &lt;&gt;\nPredicate\\Set::ne($identifier, $value);\n// Creates a Predicate\\Comparison with operator &lt;\nPredicate\\Set::lessThan($identifier, $value);\nPredicate\\Set::lt($identifier, $value);\n// Creates a Predicate\\Comparison with operator &lt;=\nPredicate\\Set::lessThanEqual($identifier, $value);\nPredicate\\Set::lte($identifier, $value);\n// Creates a Predicate\\Comparison with operator &gt;=\nPredicate\\Set::greaterThanEqual($identifier, $value);\nPredicate\\Set::gte($identifier, $value);\n// Creates a Predicate\\Comparison with operator &gt;\nPredicate\\Set::greaterThan($identifier, $value);\nPredicate\\Set::gt($identifier, $value);\n\nPredicate\\Set::like($identifier, $value, $escape); // Predicate\\Like\nPredicate\\Set::notLike($identifier, $value, $escape); // Predicate\\NotLike\n\nPredicate\\Set::between($identifier, $min, $max); // Predicate\\Between\nPredicate\\Set::notBetween($identifier, $min, $max); // Predicate\\NotBetween\n\nPredicate\\Set::in($identifier, array|Select $valueList); // Predicate\\In\nPredicate\\Set::notIn($identifier, array|Select $valueList); // Predicate\\NotIn\n\nPredicate\\Set::is($identifier, true|false|null|'UNKNOWN'); // Predicate\\Is\nPredicate\\Set::isNot($identifier, true|false|null|'UNKNOWN'); // Predicate\\IsNot\nPredicate\\Set::isNull($identifier); // Predicate\\IsNull\nPredicate\\Set::isNotNull($identifier); // Predicate\\IsNotNull\nPredicate\\Set::isTrue($identifier); // Predicate\\IsTrue\nPredicate\\Set::isFalse($identifier); // Predicate\\IsFalse\nPredicate\\Set::isUnknown($identifier); // Predicate\\IsUnknown\n\nPredicate\\Set::literal(string $literal); // Predicate\\Literal\nPredicate\\Set::expression(string $expr, array $susbtitutions); // Predicate\\Expression\nPredicate\\Set::expr(string $expr, array $susbtitutions); // Predicate\\Expression\n\nPredicate\\Set::exists($identifier, $operator, Select $select); // Predicate\\Exists\nPredicate\\Set::notExists($identifier, $operator, Select $select); // Predicate\\NotExists\n\nPredicate\\Set::all($identifier, $operator, Select $select); // Predicate\\All\nPredicate\\Set::any($identifier, $operator, Select $select); // Predicate\\Any\nPredicate\\Set::some($identifier, $operator, Select $select); // Predicate\\Some\n</code></pre> <p>Predicate sets initialized with a string will use the string to create a literal predicate:</p> <pre><code>use pine3ree\\Db\\Sql\\Predicate;\n\n// The following set will contain 1 predicate of class Predicate\\Literal\n$predicateSet = new Predicate\\Set('MAX(\"price\") &lt;= 100.0'); // MAX(\"price\") &lt;= 100.0\n</code></pre> <p>Subsets of predicates may be created using <code>begingGroup()</code> calls:</p> <pre><code>use pine3ree\\Db\\Sql\\Predicate;\n\n$predicateSet = new Predicate\\Set();\n\n// Add predicates\n\n// Begin a sub set\n// The following code will be compiled to (\"price\" &gt; :gt1 OR \"stock\" &gt; :gt2)\n$predicateSet\n    -&gt;beginGroup() // entering the subset scope\n        -&gt;gt('price', 100.0)\n        -&gt;or()\n        -&gt;gt('stock', 42)\n    -&gt;endGroup() // back to the upper-level set scope\n</code></pre> <p>Predicate sets can also be created using array specifications. This is useful when used in sql statement <code>where()</code>, <code>having()</code>, <code>on()</code> method calls.</p> <p>Examples:</p> <pre><code>use pine3ree\\Db\\Sql;\n\n$conditions = [\n    'id IS NOT NULL', // a string is converted to a literal predicate\n    ['price', '&lt;=', 100.0], // identifier, operator, value\n    ['date_created', 'between', '2020-01-01', '2020-12-31'], // identifier, operator, value, extra-value\n    ['name', 'LIKE', 'B%'], // using the 'LIKE' exact keyword\n    ['name', 'like', 'B%'], // using the lowercase alias\n    ['name', Sql::LIKE, 'B%'], // using the Sql::LIKE constant\n    ['name', '~', 'B%'], // using the '~' alias\n    ['name', 'NOT LIKE', 'A%'], // using the 'NOT LIKE' exact keywords\n    ['name', Sql::NOT_LIKE, 'A%'], // using the Sql::NOT_LIKE constant\n    ['name', 'notLike', 'A%'], // using the lowercase 'notLike' alias\n    ['name', '!~', 'A%'], // using the '!~' alias\n    ['category_id', 'in', [11, 22, 33]], // \"category_id\" IN (:in1, :in2, :in3)\n    ['store_id', 'in', [1, 2, null]], // \"store_id\" IN (:in4, :in5) OR \"store_id\" IS NULL\n    'vat_rate' =&gt; 10.0, // identifier =&gt; value implies the equality operator\n    '||' =&gt; [ // creates a group with 'OR' as default logical operator\n        // predicate-specs-1,\n        // predicate-specs-2,\n        //...\n    ],\n    '&amp;&amp;' =&gt; [ // creates a group with 'AND' as default logical operator\n        // predicate-specs-1,\n        // predicate-specs-2,\n        //...,\n    ],\n ];\n\nSql::select('*')-&gt;from('product')-&gt;where($conditions);\n</code></pre> <p>Predicate specifications may use the exact sql operator string either directly or preferably via Sql class constants, or using camelCased versions such as \"notLike\". \"LIKE\" and \"NOT LIKE\" can be specified using <code>~</code> and <code>!~</code> convenience aliases respectively.</p>"},{"location":"sql/statements/","title":"Statements","text":""},{"location":"sql/statements/#statement","title":"Statement","text":"<p><code>pine3ree\\Db\\Sql\\Statement</code></p> <p>The SQL statement classes abstract full sql statements with named placeholder markers in place of the actual parameter values. They are composed of simpler SQL elements such as identifiers, aliases, expressions, predicates and clauses.</p> <p>Statement are actually sql-statement builders and provides methods for adding the inner elements they are composed of.</p> <p>Supported statements are <code>Select</code> for DQL, and <code>Insert</code>, <code>Update</code>, <code>Delete</code> for DML, reflecting the previously examined database command classes. The sql-building methods used in a command instance are proxies to corresponding methods of the composed sql-statement instance.</p> <p>Note: The following examples replicates the exampes previously provided for their corresponding commands. The examples also outputs sql-strings as generated by the default ANSI sql-driver</p>"},{"location":"sql/statements/#sqlselect","title":"Sql::select()","text":"<p>Create a <code>pine3ree\\Sql\\Statement\\Select</code> sql statement</p> <pre><code>use pine3ree\\Db\\Sql;\n\n/** @var Db $db */\n\n$select = Sql::select(); // create a generic empty sql statement instance\n\n// SELECT * FROM \"product\"\n$select = Sql::select('*', 'product');\n$select = Sql::select('*')-&gt;from('product');\n$select = Sql::select(null, 'product');\n$select = Sql::select()-&gt;from('product');\n\n// Use table alias: SELECT \"p\".* FROM \"product\" \"p\"\n$select = Sql::select('*', 'product', 'p');\n$select = Sql::select('*')-&gt;from('product', 'p');\n$select = Sql::select()-&gt;from('product', 'p');\n\n // SELECT \"p\".\"price\", \"p\".\"vat_rate\" AS \"vatRate\" FROM \"product\" \"p\"\n$select = Sql::select(['price', 'vatRate' =&gt; 'vat_rate'])-&gt;from('product', 'p');\n\n// Add where condition LessThanEqual and order-by clause\n$select-&gt;where-&gt;lte('price', 1000.0); // WHERE \"price\" &lt;= :lte1 (named parameter marker)\n\n// ORDER BY \"p\".\"price\" ASC\n$select-&gt;orderBy('p.price', 'ASC');\n$select-&gt;orderBy('p.price', Sql::ASC);\n\n// ORDER BY \"price\" ASC, \"vat_rate\" DESC\n$select-&gt;orderBy([\n    'price' =&gt; Sql::ASC, // or just 'price' =&gt; 'ASC'\n    'vat_rate' =&gt; Sql::DESC, // or just 'vat_rate' =&gt; 'DESC'\n]);\n\n// 1. SQL-string generated via the default singleton ANSI driver\n$sql = $select-&gt;getSQL();\n\n// 2. Using a different sql-driver, assuming we have an active PDO instance\n$driver = new Sql\\Driver\\MySQL($pdo);\n$sql = $select-&gt;getSQL($driver); // e.g. SELECT `p`.* FROM `product` `p`\n\n// 2. Using an external accumulator\n$select = Sql::select();\n$select-&gt;from('user')-&gt;where-&gt;eq('id', 42);\n$sql = $select-&gt;getSQL(null, $params);\nparams-&gt;getValues(); // [':eq1' =&gt; 42]\n\n\n// SELECT\n//    \"category_id\" AS \"catId\",\n//    COUNT(*) AS \"numProducts\"\n// FROM \"product\" WHERE \"price\" &gt; :gt1\n// GROUP BY \"category_id\"\n// HAVING \"numProducts\" &gt;= :gte1\n$select = Sql::select()\n    -&gt;column('category_id', 'catId')\n    -&gt;count('*', 'numProducts')\n    -&gt;from('product');\n    -&gt;where-&gt;gte('price', 10.0);\n// using $select-&gt;where or $select-&gt;having changes the scope and the fluent interface\n// method chain is broken\n\n// Add a GROUP BY\n// GROUP BY \"category_id\" HAVING \"numProducts\" &lt; :lte1\n$select-&gt;groupBy('category_id')\n    -&gt;having-&gt;lte('numProducts', 5);\n\n// SELECT MIN(\"price\") FROM \"product\" GROUP BY \"category_id\"\n$select = Sql::select()-&gt;min('price')-&gt;from('product')-&gt;groupBy('category_id');\n</code></pre>"},{"location":"sql/statements/#sqlinsert","title":"Sql::insert()","text":"<p>Create a <code>pine3ree\\Sql\\Statement\\Insert</code> sql statement</p> <pre><code>// INSERT INTO \"product\" (\"name\", \"price\") VALUES (:val1, :val2)\n$insert = Sql::insert()\n    -&gt;into('product')\n    -&gt;row([\n        'name' =&gt; 'product-1',\n        'price' =&gt; 100.00,\n    ]);\n\n// equivalent to\n$insert = Sql::insert()\n    -&gt;into('product')\n    -&gt;columns(['name', 'price'])\n    -&gt;values(['product-1', 100.00]);\n</code></pre> <p>Insert many rows:</p> <pre><code>// INSERT INTO \"product\" (\"name\", \"price\") VALUES (:val1, :val2), (:val3, :val4)\nSql::insert()\n    -&gt;into('product')\n    -&gt;rows([\n        [\n            'name' =&gt; 'product-111',\n            'price' =&gt; 111.11,\n        ],\n        [\n            'name' =&gt; 'product-222',\n            'price' =&gt; 222.22,\n        ],\n    ]);\n\n// equivalent to\nSql::insert()\n    -&gt;into('product')\n    -&gt;row([\n        'name' =&gt; 'product-111',\n        'price' =&gt; 111.11,\n    ])\n    -&gt;row([\n        'name' =&gt; 'product-222',\n        'price' =&gt; 222.22,\n    ], true); // The TRUE argument add rows to existing insert-rows instead of replacing them\n\n// and to\nSql::insert()\n    -&gt;into('product')\n    -&gt;columns(['name', 'price'])\n    -&gt;values([\n        'product-111',\n        111.11,\n    ])\n    -&gt;values([\n        'product-222',\n        222.22,\n    ], true); // The TRUE argument add values to existing values instead of replacing them\n\n// and to\nSql::insert()\n    -&gt;into('product')\n    -&gt;columns(['name', 'price'])\n    -&gt;multipleValues([\n        [\n            'product-111',\n            111.11,\n        ],\n        [\n            'product-222',\n            222.22,\n        ],\n    ];\n</code></pre> <p>By default <code>Insert::values(array $values, bool $add = false)</code> and <code>Insert::row(array $row, bool $add = false)</code> will define the insert values removing any previously accumulated set of values.</p> <p>The opposite happens for <code>Insert::rows(array $rows, bool $add = true)</code> and <code>Insert::multipleValues(array $values, bool $add = true)</code>. These methods calls will add the new rows/values provided to the existing ones.</p> <pre><code>$insert = Sql::insert('product');\n\n$insert-&gt;row(['price' =&gt; 111.11, 'stock' =&gt; 111]); // Adds 1 set of values\n$insert-&gt;row(['price' =&gt; 222.22, 'stock' =&gt; 222], true); // Adds 1 set of values\n// Columns \"price\" and \"stock\" are already specified by previous row() calls\n$insert-&gt;values([333.33, 333], true); // Adds another set of values\n\n // Set the insert values after removing the old ones\n$insert-&gt;row(['price' =&gt; 555.55, 'stock' =&gt; 555]);\n</code></pre>"},{"location":"sql/statements/#sqlupdate","title":"Sql::update()","text":"<p>The <code>pine3ree\\Sql\\Statement\\Update</code> class abstracts a SQL INSERT statement</p> <p>A non empty condition/predicate is required, otherwise an exception is thrown.</p> <p>Examples:</p> <pre><code>// UPDATE \"product\" SET \"published\" = :set1 WHERE stock &gt; 0\n$update = Sql::update()-&gt;table('product')-&gt;set('published', true)-&gt;where('stock &gt; 0');\n$update = Sql::update('product')-&gt;set('published', true)-&gt;where('stock &gt; 0');\n\n// Update all rows\n// UPDATE \"articles\" SET \"published\" = :set1 WHERE TRUE, we use the literal \"TRUE\" to update all records\n$update = Sql::update('articles')-&gt;set('published', false)-&gt;where(\"TRUE\");\n</code></pre>"},{"location":"sql/statements/#sqldelete","title":"Sql::delete()","text":"<p>The <code>pine3ree\\Sql\\Statement\\Delete</code> class abstracts a SQL DELETE statement</p> <p>A non empty condition/predicate is required, otherwise an exception is thrown.</p> <p>Examples:</p> <pre><code>// DELETE FROM \"product\" WHERE stock &lt;= 0\n$delete = Sql::delete()-&gt;from('product')-&gt;where('stock &lt;= 0');\n$delete = Sql::delete('product')-&gt;where('stock &lt;= 0');\n\n</code></pre>"}]}